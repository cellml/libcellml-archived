// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "cellml_1_2.hxx"

namespace cellml12
{
  // model
  // 

  const model::import_sequence& model::
  import () const
  {
    return this->import_;
  }

  model::import_sequence& model::
  import ()
  {
    return this->import_;
  }

  void model::
  import (const import_sequence& s)
  {
    this->import_ = s;
  }

  const model::units_sequence& model::
  units () const
  {
    return this->units_;
  }

  model::units_sequence& model::
  units ()
  {
    return this->units_;
  }

  void model::
  units (const units_sequence& s)
  {
    this->units_ = s;
  }

  const model::component_sequence& model::
  component () const
  {
    return this->component_;
  }

  model::component_sequence& model::
  component ()
  {
    return this->component_;
  }

  void model::
  component (const component_sequence& s)
  {
    this->component_ = s;
  }

  const model::encapsulation_sequence& model::
  encapsulation () const
  {
    return this->encapsulation_;
  }

  model::encapsulation_sequence& model::
  encapsulation ()
  {
    return this->encapsulation_;
  }

  void model::
  encapsulation (const encapsulation_sequence& s)
  {
    this->encapsulation_ = s;
  }

  const model::connection_sequence& model::
  connection () const
  {
    return this->connection_;
  }

  model::connection_sequence& model::
  connection ()
  {
    return this->connection_;
  }

  void model::
  connection (const connection_sequence& s)
  {
    this->connection_ = s;
  }

  const model::name_type& model::
  name () const
  {
    return this->name_.get ();
  }

  model::name_type& model::
  name ()
  {
    return this->name_.get ();
  }

  void model::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void model::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }


  // import
  // 

  const import::units_sequence& import::
  units () const
  {
    return this->units_;
  }

  import::units_sequence& import::
  units ()
  {
    return this->units_;
  }

  void import::
  units (const units_sequence& s)
  {
    this->units_ = s;
  }

  const import::component_sequence& import::
  component () const
  {
    return this->component_;
  }

  import::component_sequence& import::
  component ()
  {
    return this->component_;
  }

  void import::
  component (const component_sequence& s)
  {
    this->component_ = s;
  }

  const import::href_type& import::
  href () const
  {
    return this->href_.get ();
  }

  import::href_type& import::
  href ()
  {
    return this->href_.get ();
  }

  void import::
  href (const href_type& x)
  {
    this->href_.set (x);
  }

  void import::
  href (::std::unique_ptr< href_type > x)
  {
    this->href_.set (std::move (x));
  }


  // units
  // 

  const units::unit_sequence& units::
  unit () const
  {
    return this->unit_;
  }

  units::unit_sequence& units::
  unit ()
  {
    return this->unit_;
  }

  void units::
  unit (const unit_sequence& s)
  {
    this->unit_ = s;
  }

  const units::name_type& units::
  name () const
  {
    return this->name_.get ();
  }

  units::name_type& units::
  name ()
  {
    return this->name_.get ();
  }

  void units::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void units::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const units::base_units_optional& units::
  base_units () const
  {
    return this->base_units_;
  }

  units::base_units_optional& units::
  base_units ()
  {
    return this->base_units_;
  }

  void units::
  base_units (const base_units_type& x)
  {
    this->base_units_.set (x);
  }

  void units::
  base_units (const base_units_optional& x)
  {
    this->base_units_ = x;
  }

  void units::
  base_units (::std::unique_ptr< base_units_type > x)
  {
    this->base_units_.set (std::move (x));
  }


  // unit
  // 

  const unit::units_type& unit::
  units () const
  {
    return this->units_.get ();
  }

  unit::units_type& unit::
  units ()
  {
    return this->units_.get ();
  }

  void unit::
  units (const units_type& x)
  {
    this->units_.set (x);
  }

  void unit::
  units (::std::unique_ptr< units_type > x)
  {
    this->units_.set (std::move (x));
  }

  const unit::multiplier_optional& unit::
  multiplier () const
  {
    return this->multiplier_;
  }

  unit::multiplier_optional& unit::
  multiplier ()
  {
    return this->multiplier_;
  }

  void unit::
  multiplier (const multiplier_type& x)
  {
    this->multiplier_.set (x);
  }

  void unit::
  multiplier (const multiplier_optional& x)
  {
    this->multiplier_ = x;
  }

  const unit::prefix_optional& unit::
  prefix () const
  {
    return this->prefix_;
  }

  unit::prefix_optional& unit::
  prefix ()
  {
    return this->prefix_;
  }

  void unit::
  prefix (const prefix_type& x)
  {
    this->prefix_.set (x);
  }

  void unit::
  prefix (const prefix_optional& x)
  {
    this->prefix_ = x;
  }

  void unit::
  prefix (::std::unique_ptr< prefix_type > x)
  {
    this->prefix_.set (std::move (x));
  }

  const unit::offset_optional& unit::
  offset () const
  {
    return this->offset_;
  }

  unit::offset_optional& unit::
  offset ()
  {
    return this->offset_;
  }

  void unit::
  offset (const offset_type& x)
  {
    this->offset_.set (x);
  }

  void unit::
  offset (const offset_optional& x)
  {
    this->offset_ = x;
  }

  const unit::exponent_optional& unit::
  exponent () const
  {
    return this->exponent_;
  }

  unit::exponent_optional& unit::
  exponent ()
  {
    return this->exponent_;
  }

  void unit::
  exponent (const exponent_type& x)
  {
    this->exponent_.set (x);
  }

  void unit::
  exponent (const exponent_optional& x)
  {
    this->exponent_ = x;
  }


  // component
  // 

  const component::units_sequence& component::
  units () const
  {
    return this->units_;
  }

  component::units_sequence& component::
  units ()
  {
    return this->units_;
  }

  void component::
  units (const units_sequence& s)
  {
    this->units_ = s;
  }

  const component::variable_sequence& component::
  variable () const
  {
    return this->variable_;
  }

  component::variable_sequence& component::
  variable ()
  {
    return this->variable_;
  }

  void component::
  variable (const variable_sequence& s)
  {
    this->variable_ = s;
  }

  const component::math_sequence& component::
  math () const
  {
    return this->math_;
  }

  component::math_sequence& component::
  math ()
  {
    return this->math_;
  }

  void component::
  math (const math_sequence& s)
  {
    this->math_ = s;
  }

  const component::name_type& component::
  name () const
  {
    return this->name_.get ();
  }

  component::name_type& component::
  name ()
  {
    return this->name_.get ();
  }

  void component::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void component::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }


  // encapsulation
  // 

  const encapsulation::component_ref_sequence& encapsulation::
  component_ref () const
  {
    return this->component_ref_;
  }

  encapsulation::component_ref_sequence& encapsulation::
  component_ref ()
  {
    return this->component_ref_;
  }

  void encapsulation::
  component_ref (const component_ref_sequence& s)
  {
    this->component_ref_ = s;
  }


  // toplevelComponentRef
  // 

  const toplevelComponentRef::component_ref_sequence& toplevelComponentRef::
  component_ref () const
  {
    return this->component_ref_;
  }

  toplevelComponentRef::component_ref_sequence& toplevelComponentRef::
  component_ref ()
  {
    return this->component_ref_;
  }

  void toplevelComponentRef::
  component_ref (const component_ref_sequence& s)
  {
    this->component_ref_ = s;
  }

  const toplevelComponentRef::component_type& toplevelComponentRef::
  component () const
  {
    return this->component_.get ();
  }

  toplevelComponentRef::component_type& toplevelComponentRef::
  component ()
  {
    return this->component_.get ();
  }

  void toplevelComponentRef::
  component (const component_type& x)
  {
    this->component_.set (x);
  }

  void toplevelComponentRef::
  component (::std::unique_ptr< component_type > x)
  {
    this->component_.set (std::move (x));
  }


  // componentRef
  // 

  const componentRef::component_ref_sequence& componentRef::
  component_ref () const
  {
    return this->component_ref_;
  }

  componentRef::component_ref_sequence& componentRef::
  component_ref ()
  {
    return this->component_ref_;
  }

  void componentRef::
  component_ref (const component_ref_sequence& s)
  {
    this->component_ref_ = s;
  }

  const componentRef::component_type& componentRef::
  component () const
  {
    return this->component_.get ();
  }

  componentRef::component_type& componentRef::
  component ()
  {
    return this->component_.get ();
  }

  void componentRef::
  component (const component_type& x)
  {
    this->component_.set (x);
  }

  void componentRef::
  component (::std::unique_ptr< component_type > x)
  {
    this->component_.set (std::move (x));
  }


  // connection
  // 

  const connection::map_variables_sequence& connection::
  map_variables () const
  {
    return this->map_variables_;
  }

  connection::map_variables_sequence& connection::
  map_variables ()
  {
    return this->map_variables_;
  }

  void connection::
  map_variables (const map_variables_sequence& s)
  {
    this->map_variables_ = s;
  }

  const connection::component_1_type& connection::
  component_1 () const
  {
    return this->component_1_.get ();
  }

  connection::component_1_type& connection::
  component_1 ()
  {
    return this->component_1_.get ();
  }

  void connection::
  component_1 (const component_1_type& x)
  {
    this->component_1_.set (x);
  }

  void connection::
  component_1 (::std::unique_ptr< component_1_type > x)
  {
    this->component_1_.set (std::move (x));
  }

  const connection::component_2_type& connection::
  component_2 () const
  {
    return this->component_2_.get ();
  }

  connection::component_2_type& connection::
  component_2 ()
  {
    return this->component_2_.get ();
  }

  void connection::
  component_2 (const component_2_type& x)
  {
    this->component_2_.set (x);
  }

  void connection::
  component_2 (::std::unique_ptr< component_2_type > x)
  {
    this->component_2_.set (std::move (x));
  }


  // importedUnits
  // 

  const importedUnits::name_type& importedUnits::
  name () const
  {
    return this->name_.get ();
  }

  importedUnits::name_type& importedUnits::
  name ()
  {
    return this->name_.get ();
  }

  void importedUnits::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void importedUnits::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const importedUnits::units_ref_type& importedUnits::
  units_ref () const
  {
    return this->units_ref_.get ();
  }

  importedUnits::units_ref_type& importedUnits::
  units_ref ()
  {
    return this->units_ref_.get ();
  }

  void importedUnits::
  units_ref (const units_ref_type& x)
  {
    this->units_ref_.set (x);
  }

  void importedUnits::
  units_ref (::std::unique_ptr< units_ref_type > x)
  {
    this->units_ref_.set (std::move (x));
  }


  // importedComponent
  // 

  const importedComponent::name_type& importedComponent::
  name () const
  {
    return this->name_.get ();
  }

  importedComponent::name_type& importedComponent::
  name ()
  {
    return this->name_.get ();
  }

  void importedComponent::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void importedComponent::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const importedComponent::component_ref_type& importedComponent::
  component_ref () const
  {
    return this->component_ref_.get ();
  }

  importedComponent::component_ref_type& importedComponent::
  component_ref ()
  {
    return this->component_ref_.get ();
  }

  void importedComponent::
  component_ref (const component_ref_type& x)
  {
    this->component_ref_.set (x);
  }

  void importedComponent::
  component_ref (::std::unique_ptr< component_ref_type > x)
  {
    this->component_ref_.set (std::move (x));
  }


  // variable
  // 

  const variable::name_type& variable::
  name () const
  {
    return this->name_.get ();
  }

  variable::name_type& variable::
  name ()
  {
    return this->name_.get ();
  }

  void variable::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void variable::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const variable::units_type& variable::
  units () const
  {
    return this->units_.get ();
  }

  variable::units_type& variable::
  units ()
  {
    return this->units_.get ();
  }

  void variable::
  units (const units_type& x)
  {
    this->units_.set (x);
  }

  void variable::
  units (::std::unique_ptr< units_type > x)
  {
    this->units_.set (std::move (x));
  }

  const variable::public_interface_optional& variable::
  public_interface () const
  {
    return this->public_interface_;
  }

  variable::public_interface_optional& variable::
  public_interface ()
  {
    return this->public_interface_;
  }

  void variable::
  public_interface (const public_interface_type& x)
  {
    this->public_interface_.set (x);
  }

  void variable::
  public_interface (const public_interface_optional& x)
  {
    this->public_interface_ = x;
  }

  void variable::
  public_interface (::std::unique_ptr< public_interface_type > x)
  {
    this->public_interface_.set (std::move (x));
  }

  const variable::private_interface_optional& variable::
  private_interface () const
  {
    return this->private_interface_;
  }

  variable::private_interface_optional& variable::
  private_interface ()
  {
    return this->private_interface_;
  }

  void variable::
  private_interface (const private_interface_type& x)
  {
    this->private_interface_.set (x);
  }

  void variable::
  private_interface (const private_interface_optional& x)
  {
    this->private_interface_ = x;
  }

  void variable::
  private_interface (::std::unique_ptr< private_interface_type > x)
  {
    this->private_interface_.set (std::move (x));
  }

  const variable::type_type& variable::
  type () const
  {
    return this->type_.get ();
  }

  variable::type_type& variable::
  type ()
  {
    return this->type_.get ();
  }

  void variable::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void variable::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }


  // mapVariables
  // 

  const mapVariables::variable_1_type& mapVariables::
  variable_1 () const
  {
    return this->variable_1_.get ();
  }

  mapVariables::variable_1_type& mapVariables::
  variable_1 ()
  {
    return this->variable_1_.get ();
  }

  void mapVariables::
  variable_1 (const variable_1_type& x)
  {
    this->variable_1_.set (x);
  }

  void mapVariables::
  variable_1 (::std::unique_ptr< variable_1_type > x)
  {
    this->variable_1_.set (std::move (x));
  }

  const mapVariables::variable_2_type& mapVariables::
  variable_2 () const
  {
    return this->variable_2_.get ();
  }

  mapVariables::variable_2_type& mapVariables::
  variable_2 ()
  {
    return this->variable_2_.get ();
  }

  void mapVariables::
  variable_2 (const variable_2_type& x)
  {
    this->variable_2_.set (x);
  }

  void mapVariables::
  variable_2 (::std::unique_ptr< variable_2_type > x)
  {
    this->variable_2_.set (std::move (x));
  }


  // cellMLIdentifier
  // 


  // unitPrefix
  //

  unitPrefix::
  unitPrefix (const char* s)
  : ::xml_schema::string (s)
  {
  }

  unitPrefix::
  unitPrefix (const ::std::string& s)
  : ::xml_schema::string (s)
  {
  }

  unitPrefix::
  unitPrefix (const unitPrefix& o,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (o, f, c)
  {
  }

  // yesno
  // 

  yesno::
  yesno (value v)
  : ::xml_schema::string (_xsd_yesno_literals_[v])
  {
  }

  yesno::
  yesno (const char* v)
  : ::xml_schema::string (v)
  {
  }

  yesno::
  yesno (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  yesno::
  yesno (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  yesno::
  yesno (const yesno& v,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  yesno& yesno::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_yesno_literals_[v]);

    return *this;
  }


  // unitPrefix_member
  // 

  unitPrefix_member::
  unitPrefix_member (value v)
  : ::xml_schema::string (_xsd_unitPrefix_member_literals_[v])
  {
  }

  unitPrefix_member::
  unitPrefix_member (const char* v)
  : ::xml_schema::string (v)
  {
  }

  unitPrefix_member::
  unitPrefix_member (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  unitPrefix_member::
  unitPrefix_member (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  unitPrefix_member::
  unitPrefix_member (const unitPrefix_member& v,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  unitPrefix_member& unitPrefix_member::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_unitPrefix_member_literals_[v]);

    return *this;
  }


  // unitPrefix_member1
  // 
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace cellml12
{
  // model
  //

  model::
  model (const name_type& name)
  : ::xml_schema::type (),
    import_ (this),
    units_ (this),
    component_ (this),
    encapsulation_ (this),
    connection_ (this),
    name_ (name, this)
  {
  }

  model::
  model (const model& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    import_ (x.import_, f, this),
    units_ (x.units_, f, this),
    component_ (x.component_, f, this),
    encapsulation_ (x.encapsulation_, f, this),
    connection_ (x.connection_, f, this),
    name_ (x.name_, f, this)
  {
  }

  model::
  model (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    import_ (this),
    units_ (this),
    component_ (this),
    encapsulation_ (this),
    connection_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void model::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // import
      //
      if (n.name () == "import" && n.namespace_ () == "http://www.cellml.org/cellml/1.2#")
      {
        ::std::unique_ptr< import_type > r (
          import_traits::create (i, f, this));

        this->import_.push_back (::std::move (r));
        continue;
      }

      // units
      //
      if (n.name () == "units" && n.namespace_ () == "http://www.cellml.org/cellml/1.2#")
      {
        ::std::unique_ptr< units_type > r (
          units_traits::create (i, f, this));

        this->units_.push_back (::std::move (r));
        continue;
      }

      // component
      //
      if (n.name () == "component" && n.namespace_ () == "http://www.cellml.org/cellml/1.2#")
      {
        ::std::unique_ptr< component_type > r (
          component_traits::create (i, f, this));

        this->component_.push_back (::std::move (r));
        continue;
      }

      // encapsulation
      //
      if (n.name () == "encapsulation" && n.namespace_ () == "http://www.cellml.org/cellml/1.2#")
      {
        ::std::unique_ptr< encapsulation_type > r (
          encapsulation_traits::create (i, f, this));

        this->encapsulation_.push_back (::std::move (r));
        continue;
      }

      // connection
      //
      if (n.name () == "connection" && n.namespace_ () == "http://www.cellml.org/cellml/1.2#")
      {
        ::std::unique_ptr< connection_type > r (
          connection_traits::create (i, f, this));

        this->connection_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  model* model::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class model (*this, f, c);
  }

  model& model::
  operator= (const model& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->import_ = x.import_;
      this->units_ = x.units_;
      this->component_ = x.component_;
      this->encapsulation_ = x.encapsulation_;
      this->connection_ = x.connection_;
      this->name_ = x.name_;
    }

    return *this;
  }

  model::
  ~model ()
  {
  }

  // import
  //

  import::
  import (const href_type& href)
  : ::xml_schema::type (),
    units_ (this),
    component_ (this),
    href_ (href, this)
  {
  }

  import::
  import (const import& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    units_ (x.units_, f, this),
    component_ (x.component_, f, this),
    href_ (x.href_, f, this)
  {
  }

  import::
  import (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    units_ (this),
    component_ (this),
    href_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void import::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // units
      //
      if (n.name () == "units" && n.namespace_ () == "http://www.cellml.org/cellml/1.2#")
      {
        ::std::unique_ptr< units_type > r (
          units_traits::create (i, f, this));

        this->units_.push_back (::std::move (r));
        continue;
      }

      // component
      //
      if (n.name () == "component" && n.namespace_ () == "http://www.cellml.org/cellml/1.2#")
      {
        ::std::unique_ptr< component_type > r (
          component_traits::create (i, f, this));

        this->component_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "href" && n.namespace_ ().empty ())
      {
        this->href_.set (href_traits::create (i, f, this));
        continue;
      }
    }

    if (!href_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "href",
        "");
    }
  }

  import* import::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class import (*this, f, c);
  }

  import& import::
  operator= (const import& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->units_ = x.units_;
      this->component_ = x.component_;
      this->href_ = x.href_;
    }

    return *this;
  }

  import::
  ~import ()
  {
  }

  // units
  //

  units::
  units (const name_type& name)
  : ::xml_schema::type (),
    unit_ (this),
    name_ (name, this),
    base_units_ (this)
  {
  }

  units::
  units (const units& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    unit_ (x.unit_, f, this),
    name_ (x.name_, f, this),
    base_units_ (x.base_units_, f, this)
  {
  }

  units::
  units (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    unit_ (this),
    name_ (this),
    base_units_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void units::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // unit
      //
      if (n.name () == "unit" && n.namespace_ () == "http://www.cellml.org/cellml/1.2#")
      {
        ::std::unique_ptr< unit_type > r (
          unit_traits::create (i, f, this));

        this->unit_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "base_units" && n.namespace_ ().empty ())
      {
        this->base_units_.set (base_units_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  units* units::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class units (*this, f, c);
  }

  units& units::
  operator= (const units& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->unit_ = x.unit_;
      this->name_ = x.name_;
      this->base_units_ = x.base_units_;
    }

    return *this;
  }

  units::
  ~units ()
  {
  }

  // unit
  //

  unit::
  unit (const units_type& units)
  : ::xml_schema::type (),
    units_ (units, this),
    multiplier_ (this),
    prefix_ (this),
    offset_ (this),
    exponent_ (this)
  {
  }

  unit::
  unit (const unit& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    units_ (x.units_, f, this),
    multiplier_ (x.multiplier_, f, this),
    prefix_ (x.prefix_, f, this),
    offset_ (x.offset_, f, this),
    exponent_ (x.exponent_, f, this)
  {
  }

  unit::
  unit (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    units_ (this),
    multiplier_ (this),
    prefix_ (this),
    offset_ (this),
    exponent_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void unit::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "units" && n.namespace_ ().empty ())
      {
        this->units_.set (units_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "multiplier" && n.namespace_ ().empty ())
      {
        this->multiplier_.set (multiplier_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "prefix" && n.namespace_ ().empty ())
      {
        this->prefix_.set (prefix_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "offset" && n.namespace_ ().empty ())
      {
        this->offset_.set (offset_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "exponent" && n.namespace_ ().empty ())
      {
        this->exponent_.set (exponent_traits::create (i, f, this));
        continue;
      }
    }

    if (!units_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "units",
        "");
    }
  }

  unit* unit::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class unit (*this, f, c);
  }

  unit& unit::
  operator= (const unit& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->units_ = x.units_;
      this->multiplier_ = x.multiplier_;
      this->prefix_ = x.prefix_;
      this->offset_ = x.offset_;
      this->exponent_ = x.exponent_;
    }

    return *this;
  }

  unit::
  ~unit ()
  {
  }

  // component
  //

  component::
  component (const name_type& name)
  : ::xml_schema::type (),
    units_ (this),
    variable_ (this),
    math_ (this),
    name_ (name, this)
  {
  }

  component::
  component (const component& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    units_ (x.units_, f, this),
    variable_ (x.variable_, f, this),
    math_ (x.math_, f, this),
    name_ (x.name_, f, this)
  {
  }

  component::
  component (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    units_ (this),
    variable_ (this),
    math_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void component::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // units
      //
      if (n.name () == "units" && n.namespace_ () == "http://www.cellml.org/cellml/1.2#")
      {
        ::std::unique_ptr< units_type > r (
          units_traits::create (i, f, this));

        this->units_.push_back (::std::move (r));
        continue;
      }

      // variable
      //
      if (n.name () == "variable" && n.namespace_ () == "http://www.cellml.org/cellml/1.2#")
      {
        ::std::unique_ptr< variable_type > r (
          variable_traits::create (i, f, this));

        this->variable_.push_back (::std::move (r));
        continue;
      }

      // math
      //
      if (n.name () == "math" && n.namespace_ () == "http://www.cellml.org/cellml/1.2#")
      {
        ::std::unique_ptr< math_type > r (
          math_traits::create (i, f, this));

        this->math_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  component* component::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class component (*this, f, c);
  }

  component& component::
  operator= (const component& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->units_ = x.units_;
      this->variable_ = x.variable_;
      this->math_ = x.math_;
      this->name_ = x.name_;
    }

    return *this;
  }

  component::
  ~component ()
  {
  }

  // encapsulation
  //

  encapsulation::
  encapsulation ()
  : ::xml_schema::type (),
    component_ref_ (this)
  {
  }

  encapsulation::
  encapsulation (const encapsulation& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    component_ref_ (x.component_ref_, f, this)
  {
  }

  encapsulation::
  encapsulation (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    component_ref_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void encapsulation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // component_ref
      //
      if (n.name () == "component_ref" && n.namespace_ () == "http://www.cellml.org/cellml/1.2#")
      {
        ::std::unique_ptr< component_ref_type > r (
          component_ref_traits::create (i, f, this));

        this->component_ref_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  encapsulation* encapsulation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class encapsulation (*this, f, c);
  }

  encapsulation& encapsulation::
  operator= (const encapsulation& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->component_ref_ = x.component_ref_;
    }

    return *this;
  }

  encapsulation::
  ~encapsulation ()
  {
  }

  // toplevelComponentRef
  //

  toplevelComponentRef::
  toplevelComponentRef (const component_type& component)
  : ::xml_schema::type (),
    component_ref_ (this),
    component_ (component, this)
  {
  }

  toplevelComponentRef::
  toplevelComponentRef (const toplevelComponentRef& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    component_ref_ (x.component_ref_, f, this),
    component_ (x.component_, f, this)
  {
  }

  toplevelComponentRef::
  toplevelComponentRef (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    component_ref_ (this),
    component_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void toplevelComponentRef::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // component_ref
      //
      if (n.name () == "component_ref" && n.namespace_ () == "http://www.cellml.org/cellml/1.2#")
      {
        ::std::unique_ptr< component_ref_type > r (
          component_ref_traits::create (i, f, this));

        this->component_ref_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "component" && n.namespace_ ().empty ())
      {
        this->component_.set (component_traits::create (i, f, this));
        continue;
      }
    }

    if (!component_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "component",
        "");
    }
  }

  toplevelComponentRef* toplevelComponentRef::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class toplevelComponentRef (*this, f, c);
  }

  toplevelComponentRef& toplevelComponentRef::
  operator= (const toplevelComponentRef& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->component_ref_ = x.component_ref_;
      this->component_ = x.component_;
    }

    return *this;
  }

  toplevelComponentRef::
  ~toplevelComponentRef ()
  {
  }

  // componentRef
  //

  componentRef::
  componentRef (const component_type& component)
  : ::xml_schema::type (),
    component_ref_ (this),
    component_ (component, this)
  {
  }

  componentRef::
  componentRef (const componentRef& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    component_ref_ (x.component_ref_, f, this),
    component_ (x.component_, f, this)
  {
  }

  componentRef::
  componentRef (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    component_ref_ (this),
    component_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void componentRef::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // component_ref
      //
      if (n.name () == "component_ref" && n.namespace_ () == "http://www.cellml.org/cellml/1.2#")
      {
        ::std::unique_ptr< component_ref_type > r (
          component_ref_traits::create (i, f, this));

        this->component_ref_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "component" && n.namespace_ ().empty ())
      {
        this->component_.set (component_traits::create (i, f, this));
        continue;
      }
    }

    if (!component_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "component",
        "");
    }
  }

  componentRef* componentRef::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class componentRef (*this, f, c);
  }

  componentRef& componentRef::
  operator= (const componentRef& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->component_ref_ = x.component_ref_;
      this->component_ = x.component_;
    }

    return *this;
  }

  componentRef::
  ~componentRef ()
  {
  }

  // connection
  //

  connection::
  connection (const component_1_type& component_1,
              const component_2_type& component_2)
  : ::xml_schema::type (),
    map_variables_ (this),
    component_1_ (component_1, this),
    component_2_ (component_2, this)
  {
  }

  connection::
  connection (const connection& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    map_variables_ (x.map_variables_, f, this),
    component_1_ (x.component_1_, f, this),
    component_2_ (x.component_2_, f, this)
  {
  }

  connection::
  connection (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    map_variables_ (this),
    component_1_ (this),
    component_2_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void connection::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // map_variables
      //
      if (n.name () == "map_variables" && n.namespace_ () == "http://www.cellml.org/cellml/1.2#")
      {
        ::std::unique_ptr< map_variables_type > r (
          map_variables_traits::create (i, f, this));

        this->map_variables_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "component_1" && n.namespace_ ().empty ())
      {
        this->component_1_.set (component_1_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "component_2" && n.namespace_ ().empty ())
      {
        this->component_2_.set (component_2_traits::create (i, f, this));
        continue;
      }
    }

    if (!component_1_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "component_1",
        "");
    }

    if (!component_2_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "component_2",
        "");
    }
  }

  connection* connection::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class connection (*this, f, c);
  }

  connection& connection::
  operator= (const connection& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->map_variables_ = x.map_variables_;
      this->component_1_ = x.component_1_;
      this->component_2_ = x.component_2_;
    }

    return *this;
  }

  connection::
  ~connection ()
  {
  }

  // importedUnits
  //

  importedUnits::
  importedUnits (const name_type& name,
                 const units_ref_type& units_ref)
  : ::xml_schema::type (),
    name_ (name, this),
    units_ref_ (units_ref, this)
  {
  }

  importedUnits::
  importedUnits (const importedUnits& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    units_ref_ (x.units_ref_, f, this)
  {
  }

  importedUnits::
  importedUnits (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (this),
    units_ref_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void importedUnits::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "units_ref" && n.namespace_ ().empty ())
      {
        this->units_ref_.set (units_ref_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!units_ref_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "units_ref",
        "");
    }
  }

  importedUnits* importedUnits::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class importedUnits (*this, f, c);
  }

  importedUnits& importedUnits::
  operator= (const importedUnits& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->name_ = x.name_;
      this->units_ref_ = x.units_ref_;
    }

    return *this;
  }

  importedUnits::
  ~importedUnits ()
  {
  }

  // importedComponent
  //

  importedComponent::
  importedComponent (const name_type& name,
                     const component_ref_type& component_ref)
  : ::xml_schema::type (),
    name_ (name, this),
    component_ref_ (component_ref, this)
  {
  }

  importedComponent::
  importedComponent (const importedComponent& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    component_ref_ (x.component_ref_, f, this)
  {
  }

  importedComponent::
  importedComponent (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (this),
    component_ref_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void importedComponent::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "component_ref" && n.namespace_ ().empty ())
      {
        this->component_ref_.set (component_ref_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!component_ref_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "component_ref",
        "");
    }
  }

  importedComponent* importedComponent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class importedComponent (*this, f, c);
  }

  importedComponent& importedComponent::
  operator= (const importedComponent& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->name_ = x.name_;
      this->component_ref_ = x.component_ref_;
    }

    return *this;
  }

  importedComponent::
  ~importedComponent ()
  {
  }

  // variable
  //

  variable::
  variable (const name_type& name,
            const units_type& units,
            const type_type& type)
  : ::xml_schema::type (),
    name_ (name, this),
    units_ (units, this),
    public_interface_ (this),
    private_interface_ (this),
    type_ (type, this)
  {
  }

  variable::
  variable (const variable& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    units_ (x.units_, f, this),
    public_interface_ (x.public_interface_, f, this),
    private_interface_ (x.private_interface_, f, this),
    type_ (x.type_, f, this)
  {
  }

  variable::
  variable (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (this),
    units_ (this),
    public_interface_ (this),
    private_interface_ (this),
    type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void variable::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "units" && n.namespace_ ().empty ())
      {
        this->units_.set (units_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "public_interface" && n.namespace_ ().empty ())
      {
        this->public_interface_.set (public_interface_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "private_interface" && n.namespace_ ().empty ())
      {
        this->private_interface_.set (private_interface_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!units_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "units",
        "");
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  variable* variable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class variable (*this, f, c);
  }

  variable& variable::
  operator= (const variable& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->name_ = x.name_;
      this->units_ = x.units_;
      this->public_interface_ = x.public_interface_;
      this->private_interface_ = x.private_interface_;
      this->type_ = x.type_;
    }

    return *this;
  }

  variable::
  ~variable ()
  {
  }

  // mapVariables
  //

  mapVariables::
  mapVariables (const variable_1_type& variable_1,
                const variable_2_type& variable_2)
  : ::xml_schema::type (),
    variable_1_ (variable_1, this),
    variable_2_ (variable_2, this)
  {
  }

  mapVariables::
  mapVariables (const mapVariables& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    variable_1_ (x.variable_1_, f, this),
    variable_2_ (x.variable_2_, f, this)
  {
  }

  mapVariables::
  mapVariables (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    variable_1_ (this),
    variable_2_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void mapVariables::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "variable_1" && n.namespace_ ().empty ())
      {
        this->variable_1_.set (variable_1_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "variable_2" && n.namespace_ ().empty ())
      {
        this->variable_2_.set (variable_2_traits::create (i, f, this));
        continue;
      }
    }

    if (!variable_1_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "variable_1",
        "");
    }

    if (!variable_2_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "variable_2",
        "");
    }
  }

  mapVariables* mapVariables::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class mapVariables (*this, f, c);
  }

  mapVariables& mapVariables::
  operator= (const mapVariables& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->variable_1_ = x.variable_1_;
      this->variable_2_ = x.variable_2_;
    }

    return *this;
  }

  mapVariables::
  ~mapVariables ()
  {
  }

  // cellMLIdentifier
  //

  cellMLIdentifier::
  cellMLIdentifier ()
  : ::xml_schema::string ()
  {
  }

  cellMLIdentifier::
  cellMLIdentifier (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  cellMLIdentifier::
  cellMLIdentifier (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  cellMLIdentifier::
  cellMLIdentifier (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  cellMLIdentifier::
  cellMLIdentifier (const cellMLIdentifier& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  cellMLIdentifier::
  cellMLIdentifier (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  cellMLIdentifier::
  cellMLIdentifier (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  cellMLIdentifier::
  cellMLIdentifier (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  cellMLIdentifier* cellMLIdentifier::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class cellMLIdentifier (*this, f, c);
  }

  cellMLIdentifier::
  ~cellMLIdentifier ()
  {
  }

  // unitPrefix
  //

  unitPrefix::
  unitPrefix (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  unitPrefix::
  unitPrefix (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  unitPrefix::
  unitPrefix (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  unitPrefix* unitPrefix::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class unitPrefix (*this, f, c);
  }

  // yesno
  //

  yesno::
  yesno (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_yesno_convert ();
  }

  yesno::
  yesno (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_yesno_convert ();
  }

  yesno::
  yesno (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_yesno_convert ();
  }

  yesno* yesno::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class yesno (*this, f, c);
  }

  yesno::value yesno::
  _xsd_yesno_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_yesno_literals_);
    const value* i (::std::lower_bound (
                      _xsd_yesno_indexes_,
                      _xsd_yesno_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_yesno_indexes_ + 2 || _xsd_yesno_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const yesno::
  _xsd_yesno_literals_[2] =
  {
    "yes",
    "no"
  };

  const yesno::value yesno::
  _xsd_yesno_indexes_[2] =
  {
    ::cellml12::yesno::no,
    ::cellml12::yesno::yes
  };

  // unitPrefix_member
  //

  unitPrefix_member::
  unitPrefix_member (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_unitPrefix_member_convert ();
  }

  unitPrefix_member::
  unitPrefix_member (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_unitPrefix_member_convert ();
  }

  unitPrefix_member::
  unitPrefix_member (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_unitPrefix_member_convert ();
  }

  unitPrefix_member* unitPrefix_member::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class unitPrefix_member (*this, f, c);
  }

  unitPrefix_member::value unitPrefix_member::
  _xsd_unitPrefix_member_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_unitPrefix_member_literals_);
    const value* i (::std::lower_bound (
                      _xsd_unitPrefix_member_indexes_,
                      _xsd_unitPrefix_member_indexes_ + 20,
                      *this,
                      c));

    if (i == _xsd_unitPrefix_member_indexes_ + 20 || _xsd_unitPrefix_member_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const unitPrefix_member::
  _xsd_unitPrefix_member_literals_[20] =
  {
    "yotta",
    "zetta",
    "exa",
    "peta",
    "tera",
    "giga",
    "mega",
    "kilo",
    "hecto",
    "deka",
    "deci",
    "centi",
    "milli",
    "micro",
    "nano",
    "pico",
    "femto",
    "atto",
    "zepto",
    "yocto"
  };

  const unitPrefix_member::value unitPrefix_member::
  _xsd_unitPrefix_member_indexes_[20] =
  {
    ::cellml12::unitPrefix_member::atto,
    ::cellml12::unitPrefix_member::centi,
    ::cellml12::unitPrefix_member::deci,
    ::cellml12::unitPrefix_member::deka,
    ::cellml12::unitPrefix_member::exa,
    ::cellml12::unitPrefix_member::femto,
    ::cellml12::unitPrefix_member::giga,
    ::cellml12::unitPrefix_member::hecto,
    ::cellml12::unitPrefix_member::kilo,
    ::cellml12::unitPrefix_member::mega,
    ::cellml12::unitPrefix_member::micro,
    ::cellml12::unitPrefix_member::milli,
    ::cellml12::unitPrefix_member::nano,
    ::cellml12::unitPrefix_member::peta,
    ::cellml12::unitPrefix_member::pico,
    ::cellml12::unitPrefix_member::tera,
    ::cellml12::unitPrefix_member::yocto,
    ::cellml12::unitPrefix_member::yotta,
    ::cellml12::unitPrefix_member::zepto,
    ::cellml12::unitPrefix_member::zetta
  };

  // unitPrefix_member1
  //

  unitPrefix_member1::
  unitPrefix_member1 (const ::xml_schema::integer& _xsd_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (_xsd_integer_base)
  {
  }

  unitPrefix_member1::
  unitPrefix_member1 (const unitPrefix_member1& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  unitPrefix_member1::
  unitPrefix_member1 (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  unitPrefix_member1::
  unitPrefix_member1 (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  unitPrefix_member1::
  unitPrefix_member1 (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  unitPrefix_member1* unitPrefix_member1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class unitPrefix_member1 (*this, f, c);
  }

  unitPrefix_member1::
  ~unitPrefix_member1 ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace cellml12
{
  ::std::unique_ptr< ::cellml12::model >
  model_ (const ::std::string& u,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::cellml12::model > (
      ::cellml12::model_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::cellml12::model >
  model_ (const ::std::string& u,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::cellml12::model > (
      ::cellml12::model_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::cellml12::model >
  model_ (const ::std::string& u,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::cellml12::model > (
      ::cellml12::model_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::cellml12::model >
  model_ (::std::istream& is,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::cellml12::model_ (isrc, f, p);
  }

  ::std::unique_ptr< ::cellml12::model >
  model_ (::std::istream& is,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::cellml12::model_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::cellml12::model >
  model_ (::std::istream& is,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::cellml12::model_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::cellml12::model >
  model_ (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::cellml12::model_ (isrc, f, p);
  }

  ::std::unique_ptr< ::cellml12::model >
  model_ (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::cellml12::model_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::cellml12::model >
  model_ (::std::istream& is,
          const ::std::string& sid,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::cellml12::model_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::cellml12::model >
  model_ (::xercesc::InputSource& i,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::cellml12::model > (
      ::cellml12::model_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::cellml12::model >
  model_ (::xercesc::InputSource& i,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::cellml12::model > (
      ::cellml12::model_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::cellml12::model >
  model_ (::xercesc::InputSource& i,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::cellml12::model > (
      ::cellml12::model_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::cellml12::model >
  model_ (const ::xercesc::DOMDocument& doc,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::cellml12::model > (
        ::cellml12::model_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "model" &&
        n.namespace_ () == "http://www.cellml.org/cellml/1.2#")
    {
      ::std::unique_ptr< ::cellml12::model > r (
        ::xsd::cxx::tree::traits< ::cellml12::model, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "model",
      "http://www.cellml.org/cellml/1.2#");
  }

  ::std::unique_ptr< ::cellml12::model >
  model_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
          ::xml_schema::flags f,
          const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "model" &&
        n.namespace_ () == "http://www.cellml.org/cellml/1.2#")
    {
      ::std::unique_ptr< ::cellml12::model > r (
        ::xsd::cxx::tree::traits< ::cellml12::model, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "model",
      "http://www.cellml.org/cellml/1.2#");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace cellml12
{
  void
  model_ (::std::ostream& o,
          const ::cellml12::model& s,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::cellml12::model_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  model_ (::std::ostream& o,
          const ::cellml12::model& s,
          ::xml_schema::error_handler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::cellml12::model_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  model_ (::std::ostream& o,
          const ::cellml12::model& s,
          ::xercesc::DOMErrorHandler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::cellml12::model_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  model_ (::xercesc::XMLFormatTarget& t,
          const ::cellml12::model& s,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::cellml12::model_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  model_ (::xercesc::XMLFormatTarget& t,
          const ::cellml12::model& s,
          ::xml_schema::error_handler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::cellml12::model_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  model_ (::xercesc::XMLFormatTarget& t,
          const ::cellml12::model& s,
          ::xercesc::DOMErrorHandler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::cellml12::model_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  model_ (::xercesc::DOMDocument& d,
          const ::cellml12::model& s,
          ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "model" &&
        n.namespace_ () == "http://www.cellml.org/cellml/1.2#")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "model",
        "http://www.cellml.org/cellml/1.2#");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  model_ (const ::cellml12::model& s,
          const ::xml_schema::namespace_infomap& m,
          ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "model",
        "http://www.cellml.org/cellml/1.2#",
        m, f));

    ::cellml12::model_ (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const model& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // import
    //
    for (model::import_const_iterator
         b (i.import ().begin ()), n (i.import ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "import",
          "http://www.cellml.org/cellml/1.2#",
          e));

      s << *b;
    }

    // units
    //
    for (model::units_const_iterator
         b (i.units ().begin ()), n (i.units ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "units",
          "http://www.cellml.org/cellml/1.2#",
          e));

      s << *b;
    }

    // component
    //
    for (model::component_const_iterator
         b (i.component ().begin ()), n (i.component ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "component",
          "http://www.cellml.org/cellml/1.2#",
          e));

      s << *b;
    }

    // encapsulation
    //
    for (model::encapsulation_const_iterator
         b (i.encapsulation ().begin ()), n (i.encapsulation ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "encapsulation",
          "http://www.cellml.org/cellml/1.2#",
          e));

      s << *b;
    }

    // connection
    //
    for (model::connection_const_iterator
         b (i.connection ().begin ()), n (i.connection ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "connection",
          "http://www.cellml.org/cellml/1.2#",
          e));

      s << *b;
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const import& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // units
    //
    for (import::units_const_iterator
         b (i.units ().begin ()), n (i.units ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "units",
          "http://www.cellml.org/cellml/1.2#",
          e));

      s << *b;
    }

    // component
    //
    for (import::component_const_iterator
         b (i.component ().begin ()), n (i.component ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "component",
          "http://www.cellml.org/cellml/1.2#",
          e));

      s << *b;
    }

    // href
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "href",
          e));

      a << i.href ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const units& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // unit
    //
    for (units::unit_const_iterator
         b (i.unit ().begin ()), n (i.unit ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "unit",
          "http://www.cellml.org/cellml/1.2#",
          e));

      s << *b;
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // base_units
    //
    if (i.base_units ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "base_units",
          e));

      a << *i.base_units ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const unit& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // units
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "units",
          e));

      a << i.units ();
    }

    // multiplier
    //
    if (i.multiplier ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "multiplier",
          e));

      a << ::xml_schema::as_double(*i.multiplier ());
    }

    // prefix
    //
    if (i.prefix ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "prefix",
          e));

      a << *i.prefix ();
    }

    // offset
    //
    if (i.offset ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "offset",
          e));

      a << ::xml_schema::as_double(*i.offset ());
    }

    // exponent
    //
    if (i.exponent ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "exponent",
          e));

      a << ::xml_schema::as_double(*i.exponent ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const component& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // units
    //
    for (component::units_const_iterator
         b (i.units ().begin ()), n (i.units ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "units",
          "http://www.cellml.org/cellml/1.2#",
          e));

      s << *b;
    }

    // variable
    //
    for (component::variable_const_iterator
         b (i.variable ().begin ()), n (i.variable ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "variable",
          "http://www.cellml.org/cellml/1.2#",
          e));

      s << *b;
    }

    // math
    //
    for (component::math_const_iterator
         b (i.math ().begin ()), n (i.math ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "math",
          "http://www.cellml.org/cellml/1.2#",
          e));

      s << *b;
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const encapsulation& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // component_ref
    //
    for (encapsulation::component_ref_const_iterator
         b (i.component_ref ().begin ()), n (i.component_ref ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "component_ref",
          "http://www.cellml.org/cellml/1.2#",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const toplevelComponentRef& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // component_ref
    //
    for (toplevelComponentRef::component_ref_const_iterator
         b (i.component_ref ().begin ()), n (i.component_ref ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "component_ref",
          "http://www.cellml.org/cellml/1.2#",
          e));

      s << *b;
    }

    // component
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "component",
          e));

      a << i.component ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const componentRef& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // component_ref
    //
    for (componentRef::component_ref_const_iterator
         b (i.component_ref ().begin ()), n (i.component_ref ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "component_ref",
          "http://www.cellml.org/cellml/1.2#",
          e));

      s << *b;
    }

    // component
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "component",
          e));

      a << i.component ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const connection& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // map_variables
    //
    for (connection::map_variables_const_iterator
         b (i.map_variables ().begin ()), n (i.map_variables ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "map_variables",
          "http://www.cellml.org/cellml/1.2#",
          e));

      s << *b;
    }

    // component_1
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "component_1",
          e));

      a << i.component_1 ();
    }

    // component_2
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "component_2",
          e));

      a << i.component_2 ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const importedUnits& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // units_ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "units_ref",
          e));

      a << i.units_ref ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const importedComponent& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // component_ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "component_ref",
          e));

      a << i.component_ref ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const variable& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // units
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "units",
          e));

      a << i.units ();
    }

    // public_interface
    //
    if (i.public_interface ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "public_interface",
          e));

      a << *i.public_interface ();
    }

    // private_interface
    //
    if (i.private_interface ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "private_interface",
          e));

      a << *i.private_interface ();
    }

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << i.type ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const mapVariables& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // variable_1
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "variable_1",
          e));

      a << i.variable_1 ();
    }

    // variable_2
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "variable_2",
          e));

      a << i.variable_2 ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const cellMLIdentifier& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const cellMLIdentifier& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const cellMLIdentifier& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const unitPrefix& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const unitPrefix& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const unitPrefix& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const yesno& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const yesno& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const yesno& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const unitPrefix_member& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const unitPrefix_member& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const unitPrefix_member& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const unitPrefix_member1& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const unitPrefix_member1& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const unitPrefix_member1& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

